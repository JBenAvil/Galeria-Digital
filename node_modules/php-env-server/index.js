// VARIABLES
const { exec, spawn } = require("child_process");
const http = require("http");
const path = require("path");
const fs = require("fs");
const URL = require("url");
const ports = require("./partials/ports");

const php_versions = {
    win32: {
        "7.3.10": path.join(__dirname, "src/php_versions/win32/php-7.3.10-Win32/"),
        "8.2.7": path.join(__dirname, "src/php_versions/win32/php-8.2.7-Win32-vs16-x64/")
    }
};
const platform = process.platform;
const is_windows = process.platform == "win32";
const server_path = path.join(__dirname, "./src");
const mimes = {
    ".php": "text/html",
    ".html": "text/html",
    ".css": "text/css",
    ".js": "application/javascript",
    ".json": "application/json",
    ".xml": "text/xml",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".png": "image/png",
    ".gif": "image/gif",
    ".pdf": "application/pdf",
    ".mp3": "audio/mpeg",
    ".wav": "audio/wav",
    ".mp4": "video/mp4",
    ".webm": "video/webm",
    ".zip": "application/zip",
    ".doc": "application/msword",
    ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ".xls": "application/vnd.ms-excel",
    ".xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ".ppt": "application/vnd.ms-powerpoint",
    ".pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
};

let php_host, php_port, php_root;


function checkURL(url = "") {
    // RETURN TYPE
    return !path.isAbsolute(url) ? "relative" : ((is_windows && /^[a-zA-Z]:\\?\/?/.test(url)) || !is_windows) ? "main" : "absolute";
};

function findProgram(program = "") {
    // RETURN path
    return new Promise((resolve, reject) => exec(`${is_windows ? "where" : "which"} ${program}`, (error, stdout, stderr) => resolve({
        error,
        stdout,
        stderr,
        paths: stdout.trim().split("\r\n").filter(Boolean)
    })));
};

function error(message) {
    // THROW ERROR
    throw new Error(message);
};

function respond(res, code, headers, data, pipe = false) {
    // SETUP res
    res.writeHead(code, headers);

    // CHECK pipe
    if (!pipe) return res.end(data);

    // CALL pipe
    fs.createReadStream(data).pipe(res);
};

async function php_handler({ req, res, access, cgi, args, env }) {
    // CALL pause
    req.pause();

    // VARIABLES
    let url = req.url;
    let script = access || url.replace(/(\.\b\w+\b).*/, "$1");
    let file = access || path.join(php_root, script);
    let php_response = "";
    let php_error = "";

    // GET php_process
    let php_process = spawn(cgi, args, {
        env: {
            // BASIC
            DOCUMENT_ROOT: php_root, // The absolute path of the web site files. It has the same value as Documents Path.
            REMOTE_ADDR: req.connection.remoteAddress || "", // The IP address of the computer that sent the request.
            REMOTE_PORT: req.connection.remotePort || "", // The port from which the request was sent.
            SERVER_SOFTWARE: "NodeJS", // The web server's software identity.
            SERVER_PROTOCOL: `HTTP/${req.httpVersion}`, // The HTTP protocol version used by the current request.
            SERVER_NAME: php_host, // The host name or the IP address of the computer running the web server as given in the requested URL.
            SERVER_PORT: php_port, // The port to which the request was sent.
            REQUEST_URI: url, // The original request URI sent by the client.
            REQUEST_METHOD: req.method, // The method used by the current request; usually set to GET or POST.
            SCRIPT_NAME: script, // The virtual path of the script being executed.
            SCRIPT_FILENAME: file,

            // ADVANCED
            REQUEST_SCHEME: req.connection.encrypted ? "https" : "http",
            SERVER_SIGNATURE: `NodeJS ${process.version}`,
            PATH_INFO: url.replace(script, ""), // Extra path information, as given in the requested URL.
            PATH_TRANSLATED: file, // The virtual-to-real mapped version of PATH_INFO.
            REQUEST_FILENAME: file, // The real path of the script being executed.
            QUERY_STRING: URL.parse(url).query || "", // The information which follows the ? character in the requested URL.
            CONTENT_TYPE: req.headers["content-type"] || "", // "application/x-www-form-urlencoded", "multipart/form-data", //The MIME type of the request body; set only for POST or PUT requests.
            CONTENT_LENGTH: req.headers["content-length"] || 0, // The length in bytes of the request body; set only for POST or PUT requests.
            AUTH_TYPE: "", // The authentication type if the client has authenticated itself to access the script.
            PHP_AUTH_USER: "", // The authentication type if the client has authenticated itself to access the script.
            REMOTE_USER: "", // The name of the user as issued by the client when authenticating itself to access the script.
            SERVER_ADDR: php_host == "localhost" ? "127.0.0.1" : php_host, // The IP address of the computer running the web server.
            GATEWAY_INTERFACE: "CGI/1.1", // The CGI Specification version supported by the web server; always set to CGI/1.1.
            REDIRECT_STATUS: 1,
            ...Object.entries(req.headers).reduce((obj, [name, value]) => Object.assign(obj, Object.fromEntries([[`HTTP_${name.toUpperCase().replace("-", "_")}`, value]])), {}), // Request Headers
            ...env
        }
    }
    );

    // SETUP php_process
    php_process.stdin.on("error", () => console.error("Error from server."));

    // CALL pipe
    req.pipe(php_process.stdin);

    // CALL resume
    req.resume();

    // SETUP php_process
    php_process.stdout.on("data", (data) => php_response += data.toString());
    php_process.stderr.on("data", (data) => php_error += data.toString());
    php_process.on("error", (err) => console.error("error", err, php_error));
    php_process.on("exit", () => {
        // CALL end
        php_process.stdin.end();

        // VARIABLES
        let separator = "\r\n\r\n";
        let split = php_response.split(separator);
        let headers = split[0].split("\r\n").map(h => h.split(": "));
        let data = {
            stdout: php_response,
            headers: {
                array: headers,
                object: headers.reduce((obj, [h, value]) => {
                    // GET cooki
                    if (h == "Set-Cookie") value = obj[h] ? [...obj[h], value] : [value];

                    // SET obj
                    obj[h] = value;

                    // RETURN obj
                    return obj;
                }, {})
            },
            html: split.slice(1).join(separator)
        };

        // CALL respond
        respond(res, 200, data.headers.object, data.html);
    });
};

// EXPORTS
exports = Object.assign(exports, {
    server: ({
        host = "localhost",
        port = 3000,
        root = "public",
        target = "system",
        version = "",
        directives = {},
        arguments = [],
        php_cgi = "",
        env = {},
    }) => new Promise(async (resolve, reject) => {
        // SET VARIABLES
        php_host = host;
        php_port = port;
        php_root = ["relative", "absolute"].includes(checkURL(root)) ? path.join(path.dirname(module.parent.filename), root) : root;

        // VARIABLES
        let port_check = await ports.check(port);
        let cgi, cgi_path, ini, args, php_path;
        let save_path = path.join(server_path, "save_path");

        // CHECK status
        if (!port_check.status) error(port_check.message);

        // SWITCH ACCORDING TO target
        switch (target) {
            case "system":
                // CHECK cgi
                if (!(cgi = (await findProgram("php-cgi")).paths[0])) error("No php-cgi detected.");

                // SET cgi_path
                cgi_path = path.dirname(cgi);

                // CHECK ini
                if (!fs.existsSync(ini = path.join(cgi_path, "php.ini"))) error(`No php.ini in ${cgi_path}.`);

                // SET args
                args = ["-c", ini];

                break;
            case "module":
                // CHECK CONDITIONS
                if (!version) error("No php version detected.");
                if (!(php_path = php_versions[platform][version])) error(`The specified php version: ${version} is not available.`);

                // SET VARIABLES
                directives = {
                    "session.save_path": save_path,
                    "curl.cainfo": path.join(server_path, "cacert.pem"),
                    ...directives
                };
                cgi = path.join(php_path, "php-cgi");
                ini = path.join(php_path, "php.ini");
                args = ["-c", ini];

                break;
            case "custom":
                // CHECK VARIABLES
                if (!(cgi = php_cgi) || !fs.existsSync(php_cgi)) error("No php-cgi detected.");

                // SET VARIABLES
                args = arguments;

                break;
            default:
                // CALL error
                error("No php target detected.");

                break;
        };

        // SET args
        args.push(...Object.entries(directives).reduce((array, [d, value]) => array.concat("-d", `${d}=${value}`), []));

        // CHECK save_path
        if (!fs.existsSync(save_path)) fs.mkdirSync(save_path, { recursive: true });

        // CALL readdir
        fs.readdir(save_path, (err, files) => {
            // CHECK err
            if (err) throw err;

            // EACH file
            files.forEach(file => fs.unlink(path.join(save_path, file), err => { if (err) throw err; }));
        });

        // GET server
        const server = http.createServer((req, res) => {
            // VARIABLES
            let url = req.url;
            let file = path.join(php_root, url);
            let extname = path.extname(file).toLowerCase();
            let icons = path.join(server_path, url);
            let dir = path.join(server_path, "dir.php");

            let is_icons = url.startsWith("/icons") && url != "/icons";
            let is_php = extname == ".php";
            let scan = is_icons ? icons : file;

            // CALL stat
            fs.stat(scan, (err, stats) => {
                // CHECK err
                if (err) {
                    // GET is_404
                    let is_404 = err.code == "ENOENT";

                    // CALL respond
                    respond(res, is_404 ? 404 : 500, { "Content-Type": "text/plain" }, is_404 ? "404 NOT FOUND" : err.message);

                    // BREAK FUNCTION
                    return;
                };

                // GET is_dir
                let is_dir = stats.isDirectory();

                // CHECK is_dir
                if (is_dir) fs.readdir(scan, (err, files) => {
                    // CHECK err
                    if (err) throw err;

                    // GET index
                    let index = "index.php";

                    // CHECK files
                    if (files.includes(index)) return respond(res, 302, { Location: path.join(url, index) }); 
                });

                // CHECK VARIABLES
                if (is_php || is_dir) return php_handler({ req, res, access: is_dir && dir, cgi, args, env });

                // CALL respond
                respond(res, 200, { "Content-Type": mimes[extname] || "application/octet-stream" }, scan, true);
            });
        });

        // SETUP server
        server.listen(php_port, php_host, () => {
            // GET url
            let url = `http://${php_host}:${php_port}`;

            // RESOLVE PROMISE
            resolve({ url, stop: () => server.close() });

            // LOG
            console.log(`PHP - Server running in ${url}`);
        });
    })
});